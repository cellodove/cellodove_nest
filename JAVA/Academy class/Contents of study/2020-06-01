
객체지향언어 자바를 사용하는이유
상속과 예외처리이다. 예외처리가 가능하기에 확장성을 가질수있다. 새로운단어 추가가능


예외처리의 개요
프로그램 실행 중에 발생하는 예상치 못한 일로 발생하는 문제를 예외이며 일반적으로 에러를 일컫는
말이다.
예외가 발생하면 프로그램은 비정상 종료된다.
비정상 종료는 프로그램이 끝까지 수행되지 못하고 중간에 종료됨을 의미한다.
프로그램을 비정상 종료하지 않고 정상 종료되게 처리하는 것을 예외처리라고 한다.
예외처리는 발생한 예외 코드를 다시 수정해서 예외가 발생하지 않도록 처리하는 방법이 아니다.
예외처리는 정상 종료와 프로그램의 계속 실행이 주목적이며 부가적으로 예외를 보고한다.
파일이나 데이터베이스와 같은 외부 자원을 사용하는 경우에는 반드시 예외처리를 해야 한다.
한번 실행된 문은 다시 실행시킬 수 없으므로 발생한 예외를 수정하는 것은 불가능하다.

예외처리의 요인과 예외처리 방법

예외처리의 요인
예외가 발생하는 요인은 다양하지만, 예외의 발생은 다음과 같다.
사용자가 데이터를 잘못 입력하는 경우이다.
개발자가 로직이나 계산을 잘못 작성한 경우이다.
JVM에 의해 하드웨어나 네트워크가 제대로 동작하지 않을 경우이다.
악의적으로 잘못된 연산을 요구하거나 시스템을 공격하는 경우이다.

예외처리 방법
프로그램 실행 중에 발생할 수 있는 예외처리 방법은 다음과 같다.
예외가 발생한 메소드 내에서 직접 처리하는 방법이 있다.
예외가 발생한 메소드를 호출한 곳으로 예외 오브젝트를 넘겨주는 방법이 있다.
개발자 정의 예외를 생성하여 처리하는 방법이 있다.

예외처리의 최상위 클래스는 Throwable 클래스이다.
Throwable 클래스의 하위로 Error 클래스와 Exception 클래스가 있다.
Exception 클래스의 하위 클래스인 RuntimeExcetption 클래스는 프로그램에서 처리하지 않는데 그 이유는
예외를 처리하기 위해 복잡한 코드가 필요하기 때문이다.
자바에서 제공하는 모든 클래스는 계층구조로 되어있다.
계층구조의 최상위로 올라가면 Object 클래스가 존재한다.


Error 클래스
Error 클래스는 애플리케이션에서 발생한 예외처리를 할 수 없는 심각한 에러와 관련된 부분이다.
JVM에서 발생한 에러는 심각한 에러이므로 애플리케이션 내에서는 예외처리를 할 수 없다.



Exception 클래스

Exception 클래스는 애플리케이션 내에서 발생하는 예외를 처리할 수 있는 클래스다.
Exception 클래스는 하위 클래스를 제공하며 실제로 예외처리를 담당하는 클래스다.

Exception 클래스의 생성자
Exception 생성자
생성자로 새로운 예외를 생성한다.
Exception(String message)
§ message 매개변수 : 지정된 메시지다.

Exception 클래스의 메소드
printStackTrace 메소드
예외에 대한 출처를 알려주고 해당 결과의 위치를 정확히 출력한다.
printStackTrace( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
getMessage 메소드
한 줄로 요약된 정보로 예외를 출력한다.
getMessage( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.


Compile Checked 계열
Compile Checked 계열의 클래스는 컴파일 시 예외처리 여부를 검사한다.
Compile Checked 계열에서 발생하는 예외처리는 개발자들의 문제라기보다는 개발자의 작업에 의해서
발생하는 경우가 많다.


ClassNotFoundException 클래스
ClassNotFoundException 클래스는 클래스 이름을 입력했을 때 클래스가 존재하지 않으면 발생한다.
일반적으로 클래스가 존재하지 않는 이유는 클래스가 등록된 패키지를 임포트 하지 않은 경우다.

FileNotFoundException 클래스
FileNotFoundException 클래스는 시스템에서 파일을 검색할 때 사용자가 없는 파일 이름을 입력했을 때
파일이 존재하지 않으면 발생한다.
일반적으로 파일이 존재하지 않는 이유는 파일이 저장된 경로를 잘못 지정했을 때다.
//사전에 없는단어라는 의미 -> 라이브러리 추가


IOException 클래스
IOException 클래스는 시스템 상황에 따라 입출력에 대한 예외가 발생할 때 발생한다.

SOLException 클래스
SOLException 클래스는 데이터베이스의 SOL 처리 작업을 할 때 발생한다.
SOLException 클래스는 상위 클래스인 Exception 클래스로 대체하는 것을 권장하지 않는다.

Compile UnChecked 계열
Compile UnChecked 계열의 클래스는 컴파일 시에는 예외가 발생하지 않고 실행할 때만 에러가 발생한다.
Compile UnChecked 계열의 클래스는 컴파일 시에 예외처리 여부를 검사하지 않는다.
컴파일 시에 예외처리 여부를 검사하지 않는 이유는 대부분의 발생하는 예외가 개발자의 부주의한
코드 작업 때문에 발생하기 때문이다.
개발자의 부주의한 코드 문제들은 코드를 이용한 검증 작업으로 예외 발생을 제거할 수 있다.

NullPointerException 클래스
NullPointerException 클래스는 변수값을 초기화하지 않고 해당 오브젝트의 변수나 메소드를 호출하는
경우에 발생한다.
//공백,인코딩,대소문자,주변환경등 여러가지 요인으로 생성됨 정확하게 뭐가 에러인지 알수없음


ArraylndexOutOfBoundsException 클래스
ArraylndexOutOfBoundsException 클래스는 배열의 인덱스가 참조하지 못할 때 발생한다.

ArithmeticException 클래스
ArithmeticException 클래스는 정수를 0으로 나누었을 때 발생한다.



메소드를 통한 예외처리
메소드를 통해서 예외 클래스로 호출하여 예외처리를 전달한다.

throw 명령어
형식
접근 제한자 지정어 반환형 메소드명([인자1, 인자2, …인자N]) {
throw new 예외 클래스명;
}

throw 명령어는 메소드의 { }(코드 블록) 안에서 예외 클래스의 인스턴스로 예외처리를 전달한다.
예외처리는 예외 클래스의 인스턴스 앞에 throw 명령어를 사용해서 던져진다.
throw 명령어로 던져진 예외는 메소드를 호출할 때에 전달된다.
throw 명령어로 던져진 예외를 받는 메소드는 예외를 처리하거나 다른 메소드로 다시 예외를 던질 수 있다.
throw 명령어로 던져진 예외 클래스는 반드시 Throwable 클래스의 하위 클래스이어야 하며 잡힌 예외를
다시 던질 때 사용된다.
개발자가 원한다면 throw 명령어를 사용해서 예외를 수동으로 던질 수 있다.
throw 명령어는 특별한 경우가 아니고는 거의 사용하지 않고 있다.


throws 명령어
형식
접근 제한자 지정어 반환형 메소드명([인자1, 인자2, …인자N]) throws 예외 클래스명{
… 실행 내용 …
}

throws 명령어는 메소드에서 상위 메소드로 예외처리를 전달한다.
메소드명 다음에 throws 명령어로 예외 클래스의 예외처리를 전달한다.
throws 명령어로 발생하는 예외의 기본단위는 메소드이다.
throws 명령어는 메소드를 호출하고 호출된 메소드가 실행하면서 예외가 발생한다.
예외가 발생한 곳에서 예외처리를 하는 것이 아니라 throws 명령어는 호출한 곳으로 예외처리를 전달하여
일괄처리를 한다.
throws 명령어를 설정하면 메소드 범위 내에서 던져질 수 있는 모든 예외를 잡거나 선언하는 것을
요구한다.
main 메소드에서 throws 명령어를 설정하는 방법이 대표적인 방법이다.
호출한 곳으로 예외처리를 전달하기 위해서는 발생한 예외를 호출한 곳으로 throws 명령어로 넘겨줘야 한다.
throws 명령어는 생성된 예외 클래스 대신에 다른 예외 클래스를 이용해서 예외처리를 하고자 할 때
사용된다.
주로 개발자가 필요로 만든 개발자 정의 예외 클래스로 예외를 처리하는 경우에 사용한다.


코드 블록을 통한 예외처리
{ }(코드 블록)을 통한 예외처리를 이용하면 코드가 복잡해 보이지만, 상황에 따라 예외에 맞게 처리를
할 수 있는 장점이 있다.
비즈니스 로직으로 사용하는 프로그램에서는 코드 블록을 통한 예외처리를 권장한다.


단일 try…catch 문
형식
try(자원) {
예외 발생 코드;
} catch(예외 클래스명 변수명) {
예외처리 코드;
}


try 문의 코드 블록 안에는 예외 발생을 정의한다.
catch 문의 코드 블록 안에는 예외처리를 정의한다.
단일 try…catch 문에서 try 문은 내부적으로 예외를 검사하고 catch 문은 예외처리를 전달한다.
단일 try…catch 문에 의한 예외처리 흐름은 다음과 같다.

try 문의 코드 블록 내에 있는 코드가 실행하는 동안 예외가 발생한다.

try 문은 발생한 예외를 처리할 수 있는 예외 클래스를 찾는다.

try 문에서는 예외 발생한 코드 이후의 실행문은 실행되지 않는다.

찾은 예외 클래스를 인스턴스 생성한다.

생성된 인스턴스는 실행되는 코드에서 참조하기 위해서 참조값을 던진다.

던져진 참조값은 catch 문의 변수명에 저장된다.

생성된 예외 클래스와 catch 문의 코드 블록에 명시된 예외 클래스가 서로 다르면 예외처리가 실패하므로 알맞은 예외 클래스를 지정해야 한다.

변수명에는 발생한 예외 정보가 저장되어 있어서 예외처리 코드를 작성할 수 있다.

catch 문으로 발생한 예외처리를 전달한다.

catch 문의 실행문이 수행되어 프로그램이 정상 종료된다.







다중 try…catch 문
형식
try {
예외 발생 코드 1;
예외 발생 코드 2;
⁝
예외 발생 코드 N;
} catch(하위 예외 클래스명1 변수명) {
예외처리 코드;
} catch(중위 예외 클래스명2 변수명) {
예외처리 코드;
} catch(상위 예외 클래스명N 변수명) {
예외처리 코드;
}


try 문의 코드 블록 안에는 다중 예외 발생을 정의한다.
다중 catch 문으로 개별 catch 문의 코드 블록 안에는 예외처리를 정의한다.
예외 클래스는 계층구조에 따라서 순차적으로 하위 예외 클래스부터 실행되어야 한다.
다중 catch 문에서 지정한 예외 클래스는 계층구조에 따라 하위 예외 클래스부터 순차적으로 예외처리를
전달해야 하며 상위 예외 클래스부터 예외처리를 하면은 에러가 발생한다.
에러 발생의 원인은 첫 번째 catch 문의 코드 블록에서 모든 예외가 처리되기 때문에 에러가 발생한다.







try…catch…finally 문
형식
try {
예외발생 코드;
} catch(예외 클래스명 변수명) {
예외처리 코드;
} finally {
예외와 관계없이 하는 실행문;
}


try…catch…finally 문의 try…catch 문은 단일 try…catch 문과 같게 수행한다.
try…catch…finally 문의 finally 코드 블록은 예외 발생 여부와 상관없이 항상 실행해야 하는 문을 정의한다.
try…catch…finally 문의 finally 코드 블록은 예외 발생 여부와 상관없이 실행하므로 외부 자원에 대한
자원 해제에 사용된다.
finally 코드 블록에서 정의되는 실행문은 파일의 입출력과 데이터베이스 연동의 자원과 같이 반드시
자원 해제를 해야 하는 문들이다.
데이터의 스트림은 데이터가 전송되고 나면은 스트림은 반드시 자원 해제를 해야 실행이 된다.
데이터베이스의 경우에는 데이터를 전송하고 나면은 다른 데이터의 전송을 위해서는 반드시 자원을
해제해야 한다.
데이터베이스의 경우에 예외가 발생하면은 자원을 해제할 수가 없으므로 반드시 finally 코드 블록에
자원 해제를 담당하는 close 메소드를 정의해야 한다.




커스텀을 통한 예외처리
형식
class UserException extends Exception {
예외처리 내용 정의;
}

커스텀 예외처리는 개발자 정의 예외처리를 의미한다.
커스텀 예외처리는 Exception 클래스를 상속받아 생성된 클래스에서 정의한다.
커스텀 예외처리는 자바에서 제공되는 예외 클래스로는 개발자가 만든 프로그램에서 발생하는 예외를
정확하게 처리할 수 없으므로 프로그램의 특정 조건에 맞지 않는 예외를 처리하기 위하여 개발자가
정의한 예외 클래스이다.
특정 상황에 대한 예외 정보를 저장할 수 없을





응답과 요청에 관하여
응답은 연결만해주는것 전화기로 표현하면 상대방 전화기로 연결하는것 그행위자차제 응답임 상대방전화기가 없어서 없다고 나오면 그것도 응답
요청은 수화기를 들어서 받는것자체, 그이후로 행하여지는 모든것이 요청이라고 말할수있다.

즉
서로 연결하는것이 응답
전송,출력은 요청이다.

서버와 클라이언트 에서는 예외처리와 스레드를 꼭필요로 한다.

스레드는 던지기만한다. 우리가 별도 작업을 할수없다. 서버가 알아서함 우선순위를 설정할수는없음 하지만 요청할수는있음
네트워크할때꼭필요함 스레드에서 슬립은꼭알아야함




스레드의 개요
프로세스는 프로그램 하나가 실행되는 단위이며 프로세스 내에서 실행되는 흐름의 단위가 스레드다.

메모장을 클릭하면 하나의 프로세스를 실행하는 것이다.
메모장을 클릭하고 동영상 플레이어를 실행했다면 두 개의 프로세스가 실행되는 것이다.
여러 개의 프로세스가 하나의 CPU에서 실행되는 것을 멀티태스킹이라고 한다.
컴퓨터는 하나의 프로세스만이 CPU에서 실행권을 가지고 실행될 수 있지만, 작은 시간으로 쪼개어
여러 프로세스가 번갈아 실행되기 때문에 사용자에게는 동시에 실행되는 것처럼 보인다.
멀티태스킹에서 프로세스는 각각의 자원을 가지게 되며 실행되기 위해서 각자의 메모리 영역을 가지고
파일 입출력을 위한 스트림을 가진다.
하나의 프로세스에서 다른 프로세스로 전환할 때 필요한 자원들을 저장해 둔 다음 다른 프로세스가
필요한 자원을 다시 불러서 실행하게 되는데 이러한 작업을 문맥 교환이라고 한다.
문맥 교환으로 작업을 실행하면 상당한 시간적 낭비를 초래한다.
비슷한 용어로 멀티 프로세스가 있으며 멀티 프로세스는 여러 개의 CPU를 가지고 처리하는 작업을의미한다.




자바는 멀티스레드를 프로그래밍 언어 차원에서 지원하며 특히 네트워크 부분에서 스레드를 이용해서 작업을 처리하면 효율적이다.
자바로 메신저 프로그램을 만들었다면 클라이언트 작업을 하는 부분의 코드와 서버 작업을 하는 부분의 코드가 존재한다.
클라이언트 역할을 하는 코드 부분에는 두 가지의 작업을 해주어야 한다.

전송 작업
사용자가 화면에 메시지를 입력하고 전송 요청을 하면은 입력한 메시지를 서버로 전송하는 작업이다.

출력 작업
서버에서 다른 사용자가 전송한 메시지를 보내오면은 해당 메시지를 전송받아서 사용자가 볼 수 있도록
화면에 출력해 주는 작업이다.
전송과 출력 작업을 하나의 작업 단위로 처리하게 되면 하나의 작업이 실행될 때에 작업이 끝날 때까지
기다렸다가 다른 작업을 수행해야 한다.
사용자가 입력한 메시지는 서버로 전송한 작업이 다 끝내기 전에는 사용자 화면에 입력한 메시지를
출력할 수 없으므로 이런 경우에 두 작업을 스레드 단위로 처리하면 스레드 두 개가 동시에 작업을
수행하는 것처럼 처리해 줄 수 있다.

작업 스레드1
입력한 메시지를 서버에 전송하는 작업을 수행한다.
작업 스레드2
서버에서 전송되어 오는 메시지를 사용자의 화면에 출력하는 작업을 수행한다.




스레드의 생성
프로세스는 보통 하나의 프로그램 처리 경로인 루틴을 가지고 있으며 직렬 처리로 실행한다.
프로세스는 어떠한 일을 수행하는 것에 있어 개발자가 원하는 순서대로 일을 처리한다.
순서대로 일을 처리하지 않고 분리해서 동시에 처리하고자 할 때 스레드를 사용한다.
스레드를 이용하면 하나의 프로세스에서도 여러 개의 처리 루틴을 가질 수 있는 병렬 처리가 가능하다.

단순 반복의 코드를 실행할 때도 여러 개의 스레드를 만들어서 분리하고 그 뒤에 결과 데이터를 받아 합치면 그만큼 시간을 절약할 수 있다.
스레드의 생성은 Runnable 인터페이스와 Thread 클래스를 사용한다.
Thread 클래스를 상속받아서 스레드를 구현한 자식 클래스는 다른 클래스를 상속받을 수 없지만,
Runnable 인터페이스를 상속받은 자식 클래스는 다른 클래스를 상속받을 수 있다.
다형성 적용이 필요하면 Runnable 인터페이스로 생성하지만, 일반적으로는 Thread 클래스로 스레드를 생성한다.
스레드를 시작하기 위해서는 반드시 start 메소드를 이용한다.
직접 스레드의 run 메소드를 호출하지 못하고 start 메소드를 호출하면 내부적으로 run 메소드를 호출하여 스레드를 시작한다.


Thread 클래스
Thread 클래스의 개요
Thread 클래스는 Runnable 인터페이스의 구현체로 프로그램 내에서의 실행 스레드이다.
Thread 클래스는 Runnable 인터페이스의 추상 메소드인 run 메소드를 상속받는다.
Thread 클래스에서 스레드가 처리해야 하는 작업은 run 메소드에서 구현하면 되고 run 메소드가 끝나면
스레드는 제거된다.
Thread 클래스는 병렬에 실행되는 복수의 스레드를 사용할 수가 있다.
Thread 클래스는 각 스레드에는 우선순위를 부여할 수 있으며 우선순위가 높은 스레드는 우선순위의
낮은 스레드보다 우선 실행된다.
Thread 클래스에 의한 스레드 생성 흐름은 다음과 같다.

Thread 클래스를 상속받는 클래스를 작성한다.

public void run 메소드를 오버라이딩 한다.

main 메소드에서 클래스의 인스턴스 생성한다.

생성한 인스턴스의 start 메소드를 호출하여 스레드를 실행시킨다.





Runnable 인터페이스
Runnable 인터페이스의 개요
Runnable 인터페이스는 스레드를 지원한다.
Runnable 인터페이스는 스레드에 의해 인스턴스가 실행되도록 구현된 클래스에 의해 구현한다.
Runnable 인터페이스에는 run 추상 메소드 하나만 정의되어 있다.
Runnable 인터페이스의 구현체를 이용해서 스레드를 구현했을 때 구현체는 run 추상 메소드로 구현한다.
Runnable 인터페이스에서 스레드의 인스턴스를 생성하려면 Thread 클래스에서 제공되는 생성자를 사용해야 한다.



스레드의 생명주기
스레드의 생명주기는 프로세스 안에서 시작점과 종료점을 가지는 일련 된 하나의 작업 흐름이다.

Startable 상태
시작 상태는 스레드를 인스턴스 생성한 상태로 Thread 클래스를 상속받거나 Runnable 인터페이스를
구현한 클래스를 생성한다.

Runnable 상태
준비 상태는 생성된 스레드에 start 메소드를 호출하는 경우의 상태로 스레드를 실행하기 위한 준비 단계다.
준비 상태는 CPU를 점유하고 있지 않으며 실행을 하기 위해 대기하고 있는 상태다.
start 메소드를 호출하면 run 메소드에 설정된 스레드가 준비 상태로 진입한다.

Blocked 상태
지연 상태는 실행되고 있던 스레드가 run 메소드를 모두 끝마치지 못하고 중간에 중지된 상태다.
지연 상태는 CPU를 점유권을 상실한 상태로 후에 특정 메소드를 실행시켜 준비 상태로 전환한다.
wait 메소드에 의해 지연 상태가 된 스레드는 notify 메소드가 호출되면 준비 상태가 된다.

Running 상태
실행 상태는 CPU를 점유하여 실행하고 있는 상태다.
실행 상태는 스레드의 run 메소드를 실행한다.
실행 상태는 준비 상태의 스레드를 실행 상태로 이동하여 실제로 스레드가 동작하는 상태다.
준비 상태에 있는 여러 스레드 중 우선순위를 가진 스레드가 결정되면 JVM이 자동으로 run 메소드를
호출하여 스레드가 실행 상태로 진입한다.

Dead 상태
종료 상태는 실행 상태에서 스레드가 모두 실행되고 난 후 완료 상태다.
종료 상태는 실행되고 있던 스레드가 run 메소드를 모두 처리하여 스레드가 제거되는 상태이다.
종료 상태에서는 run 메소드의 실행이 끝나면 스레드를 종료하므로 다시 스레드를 실행할 수가 없다.




스레드의 우선순위
시작점 역할을 담당하는 main 메소드를 실행시키는 것도 스레드가 담당한다.
스레드는 우선권을 가지며 자바의 우선권은 1부터 10까지 값을 가질 수 있다.
우선권이 높을수록 실행될 가능성이 더 커진다.
우선순위가 같은 스레드가 동시에 여러 개 실행되면 어떤 스레드가 실행될지 알 수 없으므로 스레드 중에
중요한 작업을 하는 스레드는 다른 스레드보다 작업 시간을 더 할애해야 한다.
스레드 중에 중요한 작업을 하는 스레드의 우선순위를 높게 설정하면은 스레드가 정확하게 어떤 시점에
몇 번 실행되게 할지는 정확히 설정할 수 없지만, 우선순위가 높으므로 우선순위가 낮은 스레드보다
더 많이 CPU를 점유하게 할 수 있다.

스레드 우선순위의 상수는 다음과 같다.

MAX_PRIORITY 상수
최대 우선순위를 지정한다.

MIN_PRIORITY 상수
최소 우선순위를 지정한다.

NORM_PRIORITY 상수
중간 우선순위로 우선순위를 지정하지 않았을 때 지정하며 기본값이다.


스레드의 블록
영어인 block의 의미는 막는다는 의미가 되지만, 여기서는 지연이 된다.
현재 실행되고 있는 스레드를 지연시키는 경우는 다양하다.
자바의 입출력이나 인터럽트 요청이 발생하면 자동으로 실행 중인 스레드가 지연된다.
자바의 입출력 같은 작업은 다른 어떤 작업보다도 먼저 수행되어야 하므로 먼저 수행되고 있는 스레드를
지연시키고 입출력 작업을 수행하게 된다.

스레드의 메소드에서 지연이 가능한 메소드는 sleep 메소드, yield 메소드, join 메소드다.






















