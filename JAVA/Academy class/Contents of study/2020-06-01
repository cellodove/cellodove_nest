
객체지향언어 자바를 사용하는이유
상속과 예외처리이다. 예외처리가 가능하기에 확장성을 가질수있다. 새로운단어 추가가능


예외처리의 개요
프로그램 실행 중에 발생하는 예상치 못한 일로 발생하는 문제를 예외이며 일반적으로 에러를 일컫는
말이다.
예외가 발생하면 프로그램은 비정상 종료된다.
비정상 종료는 프로그램이 끝까지 수행되지 못하고 중간에 종료됨을 의미한다.
프로그램을 비정상 종료하지 않고 정상 종료되게 처리하는 것을 예외처리라고 한다.
예외처리는 발생한 예외 코드를 다시 수정해서 예외가 발생하지 않도록 처리하는 방법이 아니다.
예외처리는 정상 종료와 프로그램의 계속 실행이 주목적이며 부가적으로 예외를 보고한다.
파일이나 데이터베이스와 같은 외부 자원을 사용하는 경우에는 반드시 예외처리를 해야 한다.
한번 실행된 문은 다시 실행시킬 수 없으므로 발생한 예외를 수정하는 것은 불가능하다.

예외처리의 요인과 예외처리 방법

예외처리의 요인
예외가 발생하는 요인은 다양하지만, 예외의 발생은 다음과 같다.
사용자가 데이터를 잘못 입력하는 경우이다.
개발자가 로직이나 계산을 잘못 작성한 경우이다.
JVM에 의해 하드웨어나 네트워크가 제대로 동작하지 않을 경우이다.
악의적으로 잘못된 연산을 요구하거나 시스템을 공격하는 경우이다.

예외처리 방법
프로그램 실행 중에 발생할 수 있는 예외처리 방법은 다음과 같다.
예외가 발생한 메소드 내에서 직접 처리하는 방법이 있다.
예외가 발생한 메소드를 호출한 곳으로 예외 오브젝트를 넘겨주는 방법이 있다.
개발자 정의 예외를 생성하여 처리하는 방법이 있다.

예외처리의 최상위 클래스는 Throwable 클래스이다.
Throwable 클래스의 하위로 Error 클래스와 Exception 클래스가 있다.
Exception 클래스의 하위 클래스인 RuntimeExcetption 클래스는 프로그램에서 처리하지 않는데 그 이유는
예외를 처리하기 위해 복잡한 코드가 필요하기 때문이다.
자바에서 제공하는 모든 클래스는 계층구조로 되어있다.
계층구조의 최상위로 올라가면 Object 클래스가 존재한다.


Error 클래스
Error 클래스는 애플리케이션에서 발생한 예외처리를 할 수 없는 심각한 에러와 관련된 부분이다.
JVM에서 발생한 에러는 심각한 에러이므로 애플리케이션 내에서는 예외처리를 할 수 없다.



Exception 클래스

Exception 클래스는 애플리케이션 내에서 발생하는 예외를 처리할 수 있는 클래스다.
Exception 클래스는 하위 클래스를 제공하며 실제로 예외처리를 담당하는 클래스다.

Exception 클래스의 생성자
Exception 생성자
생성자로 새로운 예외를 생성한다.
Exception(String message)
§ message 매개변수 : 지정된 메시지다.

Exception 클래스의 메소드
printStackTrace 메소드
예외에 대한 출처를 알려주고 해당 결과의 위치를 정확히 출력한다.
printStackTrace( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
getMessage 메소드
한 줄로 요약된 정보로 예외를 출력한다.
getMessage( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.


Compile Checked 계열
Compile Checked 계열의 클래스는 컴파일 시 예외처리 여부를 검사한다.
Compile Checked 계열에서 발생하는 예외처리는 개발자들의 문제라기보다는 개발자의 작업에 의해서
발생하는 경우가 많다.


ClassNotFoundException 클래스
ClassNotFoundException 클래스는 클래스 이름을 입력했을 때 클래스가 존재하지 않으면 발생한다.
일반적으로 클래스가 존재하지 않는 이유는 클래스가 등록된 패키지를 임포트 하지 않은 경우다.

FileNotFoundException 클래스
FileNotFoundException 클래스는 시스템에서 파일을 검색할 때 사용자가 없는 파일 이름을 입력했을 때
파일이 존재하지 않으면 발생한다.
일반적으로 파일이 존재하지 않는 이유는 파일이 저장된 경로를 잘못 지정했을 때다.
//사전에 없는단어라는 의미 -> 라이브러리 추가


IOException 클래스
IOException 클래스는 시스템 상황에 따라 입출력에 대한 예외가 발생할 때 발생한다.

SOLException 클래스
SOLException 클래스는 데이터베이스의 SOL 처리 작업을 할 때 발생한다.
SOLException 클래스는 상위 클래스인 Exception 클래스로 대체하는 것을 권장하지 않는다.

Compile UnChecked 계열
Compile UnChecked 계열의 클래스는 컴파일 시에는 예외가 발생하지 않고 실행할 때만 에러가 발생한다.
Compile UnChecked 계열의 클래스는 컴파일 시에 예외처리 여부를 검사하지 않는다.
컴파일 시에 예외처리 여부를 검사하지 않는 이유는 대부분의 발생하는 예외가 개발자의 부주의한
코드 작업 때문에 발생하기 때문이다.
개발자의 부주의한 코드 문제들은 코드를 이용한 검증 작업으로 예외 발생을 제거할 수 있다.

NullPointerException 클래스
NullPointerException 클래스는 변수값을 초기화하지 않고 해당 오브젝트의 변수나 메소드를 호출하는
경우에 발생한다.
//공백,인코딩,대소문자,주변환경등 여러가지 요인으로 생성됨 정확하게 뭐가 에러인지 알수없음


ArraylndexOutOfBoundsException 클래스
ArraylndexOutOfBoundsException 클래스는 배열의 인덱스가 참조하지 못할 때 발생한다.

ArithmeticException 클래스
ArithmeticException 클래스는 정수를 0으로 나누었을 때 발생한다.



메소드를 통한 예외처리
메소드를 통해서 예외 클래스로 호출하여 예외처리를 전달한다.

throw 명령어
형식
접근 제한자 지정어 반환형 메소드명([인자1, 인자2, …인자N]) {
throw new 예외 클래스명;
}

throw 명령어는 메소드의 { }(코드 블록) 안에서 예외 클래스의 인스턴스로 예외처리를 전달한다.
예외처리는 예외 클래스의 인스턴스 앞에 throw 명령어를 사용해서 던져진다.
throw 명령어로 던져진 예외는 메소드를 호출할 때에 전달된다.
throw 명령어로 던져진 예외를 받는 메소드는 예외를 처리하거나 다른 메소드로 다시 예외를 던질 수 있다.
throw 명령어로 던져진 예외 클래스는 반드시 Throwable 클래스의 하위 클래스이어야 하며 잡힌 예외를
다시 던질 때 사용된다.
개발자가 원한다면 throw 명령어를 사용해서 예외를 수동으로 던질 수 있다.
throw 명령어는 특별한 경우가 아니고는 거의 사용하지 않고 있다.


throws 명령어
형식
접근 제한자 지정어 반환형 메소드명([인자1, 인자2, …인자N]) throws 예외 클래스명{
… 실행 내용 …
}

throws 명령어는 메소드에서 상위 메소드로 예외처리를 전달한다.
메소드명 다음에 throws 명령어로 예외 클래스의 예외처리를 전달한다.
throws 명령어로 발생하는 예외의 기본단위는 메소드이다.
throws 명령어는 메소드를 호출하고 호출된 메소드가 실행하면서 예외가 발생한다.
예외가 발생한 곳에서 예외처리를 하는 것이 아니라 throws 명령어는 호출한 곳으로 예외처리를 전달하여
일괄처리를 한다.
throws 명령어를 설정하면 메소드 범위 내에서 던져질 수 있는 모든 예외를 잡거나 선언하는 것을
요구한다.
main 메소드에서 throws 명령어를 설정하는 방법이 대표적인 방법이다.
호출한 곳으로 예외처리를 전달하기 위해서는 발생한 예외를 호출한 곳으로 throws 명령어로 넘겨줘야 한다.
throws 명령어는 생성된 예외 클래스 대신에 다른 예외 클래스를 이용해서 예외처리를 하고자 할 때
사용된다.
주로 개발자가 필요로 만든 개발자 정의 예외 클래스로 예외를 처리하는 경우에 사용한다.


코드 블록을 통한 예외처리
{ }(코드 블록)을 통한 예외처리를 이용하면 코드가 복잡해 보이지만, 상황에 따라 예외에 맞게 처리를
할 수 있는 장점이 있다.
비즈니스 로직으로 사용하는 프로그램에서는 코드 블록을 통한 예외처리를 권장한다.


단일 try…catch 문
형식
try(자원) {
예외 발생 코드;
} catch(예외 클래스명 변수명) {
예외처리 코드;
}


try 문의 코드 블록 안에는 예외 발생을 정의한다.
catch 문의 코드 블록 안에는 예외처리를 정의한다.
단일 try…catch 문에서 try 문은 내부적으로 예외를 검사하고 catch 문은 예외처리를 전달한다.
단일 try…catch 문에 의한 예외처리 흐름은 다음과 같다.

try 문의 코드 블록 내에 있는 코드가 실행하는 동안 예외가 발생한다.

try 문은 발생한 예외를 처리할 수 있는 예외 클래스를 찾는다.

try 문에서는 예외 발생한 코드 이후의 실행문은 실행되지 않는다.

찾은 예외 클래스를 인스턴스 생성한다.

생성된 인스턴스는 실행되는 코드에서 참조하기 위해서 참조값을 던진다.

던져진 참조값은 catch 문의 변수명에 저장된다.

생성된 예외 클래스와 catch 문의 코드 블록에 명시된 예외 클래스가 서로 다르면 예외처리가 실패하므로 알맞은 예외 클래스를 지정해야 한다.

변수명에는 발생한 예외 정보가 저장되어 있어서 예외처리 코드를 작성할 수 있다.

catch 문으로 발생한 예외처리를 전달한다.

catch 문의 실행문이 수행되어 프로그램이 정상 종료된다.







다중 try…catch 문
형식
try {
예외 발생 코드 1;
예외 발생 코드 2;
⁝
예외 발생 코드 N;
} catch(하위 예외 클래스명1 변수명) {
예외처리 코드;
} catch(중위 예외 클래스명2 변수명) {
예외처리 코드;
} catch(상위 예외 클래스명N 변수명) {
예외처리 코드;
}


try 문의 코드 블록 안에는 다중 예외 발생을 정의한다.
다중 catch 문으로 개별 catch 문의 코드 블록 안에는 예외처리를 정의한다.
예외 클래스는 계층구조에 따라서 순차적으로 하위 예외 클래스부터 실행되어야 한다.
다중 catch 문에서 지정한 예외 클래스는 계층구조에 따라 하위 예외 클래스부터 순차적으로 예외처리를
전달해야 하며 상위 예외 클래스부터 예외처리를 하면은 에러가 발생한다.
에러 발생의 원인은 첫 번째 catch 문의 코드 블록에서 모든 예외가 처리되기 때문에 에러가 발생한다.







try…catch…finally 문
형식
try {
예외발생 코드;
} catch(예외 클래스명 변수명) {
예외처리 코드;
} finally {
예외와 관계없이 하는 실행문;
}


try…catch…finally 문의 try…catch 문은 단일 try…catch 문과 같게 수행한다.
try…catch…finally 문의 finally 코드 블록은 예외 발생 여부와 상관없이 항상 실행해야 하는 문을 정의한다.
try…catch…finally 문의 finally 코드 블록은 예외 발생 여부와 상관없이 실행하므로 외부 자원에 대한
자원 해제에 사용된다.
finally 코드 블록에서 정의되는 실행문은 파일의 입출력과 데이터베이스 연동의 자원과 같이 반드시
자원 해제를 해야 하는 문들이다.
데이터의 스트림은 데이터가 전송되고 나면은 스트림은 반드시 자원 해제를 해야 실행이 된다.
데이터베이스의 경우에는 데이터를 전송하고 나면은 다른 데이터의 전송을 위해서는 반드시 자원을
해제해야 한다.
데이터베이스의 경우에 예외가 발생하면은 자원을 해제할 수가 없으므로 반드시 finally 코드 블록에
자원 해제를 담당하는 close 메소드를 정의해야 한다.




커스텀을 통한 예외처리
형식
class UserException extends Exception {
예외처리 내용 정의;
}

커스텀 예외처리는 개발자 정의 예외처리를 의미한다.
커스텀 예외처리는 Exception 클래스를 상속받아 생성된 클래스에서 정의한다.
커스텀 예외처리는 자바에서 제공되는 예외 클래스로는 개발자가 만든 프로그램에서 발생하는 예외를
정확하게 처리할 수 없으므로 프로그램의 특정 조건에 맞지 않는 예외를 처리하기 위하여 개발자가
정의한 예외 클래스이다.
특정 상황에 대한 예외 정보를 저장할 수 없을





































