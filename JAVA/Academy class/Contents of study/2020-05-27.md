

static 지정어
static 지정어는 클래스, 변수, 메소드의 지정자로 사용할 수 있으며 단 한 번만 생성된다.
static 지정어는 전역적 의미로 어디에서 접근하든 그 상태를 유지할 수 있는 공유의 기능을 가진다.
static 지정어로 선언한 변수는 공유 변수이므로 오버라이딩이 불가능하다.

static 멤버변수
클래스 영역에서 static 명령어와 함께 선언한 멤버변수를 스테틱 멤버변수라고 한다.
static 멤버변수는 new 명령어로 생성한 인스턴스를 참조하지 않고 직접 접근한다.
static 멤버변수는 다른 언어의 전역변수와 같이 생성된 모든 인스턴스에서 공유가 이루어져 인스턴스를
같이 사용할 수가 있다.
static 멤버변수는 프로그램이 실행할 때 자동 생성되고 프로그램이 종료될 때 자동 삭제된다.
static 멤버변수는 인스턴스 생성과 관련이 없으므로 생성된 모든 인스턴스에서 공유할 수 있고 클래스로
직접 접근할 수 있다.
static 멤버변수는 자료값의 공유하기 위해 선언한 공간이다.

static 메소드
static 메소드 안에서는 인스턴스 멤버변수를 사용할 수 없는데 그 이유는 static 지정어의 초기화 시점이
인스턴스 멤버변수보다 빠르기 때문이다.
static 메소드 내에서는 일반 메소드도 호출할 수 없다.
인스턴스 멤버변수나 일반 메소드를 static 메소드 안에서 참조하려면 인스턴스를 생성한 후 인스턴스를
통해서 참조해야 한다.

static 임포트
static 임포트는 JDK 5 버전에서 추가된 기능으로 static 변수나 static 메소드를 임포트 하는 기능으로
자바에서 특정 클래스를 임포트 한다.
자주 사용되는 유틸리티 클래스 안의 메소드를 static 지정어로 정의하고 다른 클래스에서 static 임포트를
정의해서 사용한다.


final 지정어
final 지정어로 선언을 하면 재사용과 상속을 할 수 없다.
final 지정어는 클래스, 메소드, 변수에 지정할 수 있다.

클래스 지정
final 지정어가 클래스에 지정되면 해당 클래스는 상속할 수 없다.
final 지정어가 클래스에 지정되면 변경되거나 확장될 수 없는 클래스가 된다.


메소드 지정
final 지정어가 메소드에 지정되면 해당 메소드를 오버라이딩이 불가능하다.
final 지정어가 메소드에 지정되면 변경될 수 없는 메소드가 된다.

변수 지정
final 지정어로 변수를 선언하면 상수가 되며 상수 변수라고도 한다.
상수는 고유한 자료형의 값으로 항상 같은 의미가 있는 변수가 된다.
상수는 변수와 구분하기 위하여 일반적으로 상수명은 대문자로 표시한다.
상수는 단 한 번 초기화를 거칠 수 있으며 절대 변경이 불가능하다.

final 지정어가 변수 앞에 지정되면 변수값은 프로그램 실행 중에 변경할 수 없다.
final 지정어는 주로 상수를 정의할 때 변수 앞에 사용된다.
final 지정어 앞에 static 지정어가 오면 해당 클래스를 사용하는 모든 인스턴스에서 공유하는 상수를
의미하므로 인스턴스 생성 없이 클래스 이름으로 쉽게 접근할 수 있다.
클래스의 상수는 일반적으로 static final로 선언해서 전역적인 상수를 만들어서 사용하는 경우가 많다.
상수가 선언된 클래스에서는 매개변수로 값을 변경하여 저장하는 setter 메소드를 선언할 수가 없다.
인터페이스에서 멤버변수를 선언하면 자동으로 상수가 되며 그 이유는 인터페이스에서는 생성자가
없기 때문이다.



this 지정어
this 지정어는 자기 자신을 참조한다.

멤버변수와 매개변수명이 같은 경우
this.멤버변수명 = 매개변수명;

this 지정어는 인스턴스를 참조하며 멤버변수명과 매개변수명을 같게 사용한다.
this 지정어는 메모리에 올라간 자기 자신을 상속하고 현재의 인스턴스를 가리킨다.
this 지정어는 멤버변수명과 매개변수명이 같을 때 구분하기 위해서 사용된다.
this 지정어는 인스턴스 생성 후에 메모리에 생성된 자기 자신의 인스턴스를 의미하는 것으로 인스턴스가
자기 자신을 가리킬 때 사용될 수 있다.

오버로딩 생성자의 인자를 호출하는 경우
 this(멤버변수값1, 멤버변수값2, …멤버변수값N)
 
this 지정어는 클래스 내에서 오버로딩 생성자의 인자를 호출할 때도 사용된다.
this 지정어는 반드시 생성자 첫 라인에서 사용해야 하며 인자 리스트가 반드시 일치해야 한다.
this 지정어는 생성자를 여러 개 정의해서 인스턴스 멤버변수를 초기화할 때에 사용한다.
멤버변수를 초기화시키는 코드를 모든 생성자에서 정의하면 중복 코드가 발생하므로 this 지정어를
사용하여 멤버변수를 초기화시키는 코드를 특정 생성자에 정의하고 다른 생성자들에서는 해당 생성자를
호출해서 초기화를 실행할 수 있다.
this 지정어는 나머지 생성자에서는 초기화 작업을 하는 특정 생성자에게 요청하여 중복을 제거할 수 있다.


super 지정어
super 지정어는 부모의 인스턴스를 상속하며 부모 인스턴스를 가리키는 참조 변수이다.
super 지정어는 부모 클래스에서 자식 클래스의 구성 요소를 명시적으로 호출할 때 사용한다.
super 지정어는 상속의 개념을 이용하여 프로그램의 재사용을 지원한다.


부모 클래스의 멤버변수명과 자식 클래스의 멤버변수명이 같은 경우
 super.멤버변수명
 
super 지정어는 자식 클래스에서 부모 클래스의 멤버변수를 사용할 수 있지만, 특별한 목적으로
부모 클래스의 멤버변수를 명시적으로 호출할 수 있다.
super 지정어를 사용하여 부모 멤버변수를 호출한다.

자식 클래스에서 명시적으로 부모 클래스의 필드 생성자를 호출하는 경우
 super(필드 생성자의 인자)
 
super 지정어를 사용하여 부모 클래스의 필드 생성자의 인자를 호출하며 반드시 자식 생성자의 첫 라인에서
호출해야 한다.



추상 클래스의 개요
추상 클래스는 추상 메소드를 포함하는 클래스로 추상 메소드와 클래스의 구성을 다 포함하고 있다.
추상 클래스는 클래스에 추상 메소드를 추가한 클래스라고 생각하면 된다.
추상 클래스는 인스턴스를 발생시킬 수 없는 것을 제외하면 클래스와 같다.
클래스를 설계도에 비유한다면 추상 클래스는 미완성 설계도에 비유할 수 있다.
클래스가 미완성이라는 것은 미완성 메소드인 추상 메소드를 포함하고 있다는 의미다.
미완성 설계도로 완성된 제품을 만들 수 없듯이 추상 클래스로 인스턴스는 생성할 수 없다.
추상 클래스는 상속을 통해서 자식 클래스에 의해서만 완성될 수 있다.
추상 클래스는 생성자를 가지고 있지만, 자체적으로 new 명령어를 이용해서 생성자를 호출하여 인스턴스를
생성할 수 없다는 것이 클래스와의 큰 차이점이다.

예시 AbstractA abstractA  new AbstractA( );

상속을 적용하면 코드의 재사용성과 다형성 등을 적용할 수 있지만, 강력한 상속을 적용해도 자식 클래스에서
부모의 메소드를 상속받아서 사용하지 않고 개발한다면 상속을 사용하는 장점을 얻을 수 없다.
자바에서는 추상 메소드로 메소드를 강제함으로써 일관성을 유지할 수 있다.
추상 클래스는 추상 메소드로 자식 클래스의 전체 메소드가 아닌 특정 메소드를 강제할 목적으로 사용한다.
추상 클래스는 구현체의 공통적인 특성을 추출하여 선언하고 자식 클래스에 강제하는 것이다.
구현체는 인스턴스를 직접 생성할 수 있는 클래스로 실체 클래스라고도 한다.
추상 클래스의 상속은 클래스의 상속과 같다.
추상 클래스에서 인스턴스를 생성하기 위해서는 상속을 통해서 구현체로 구현한다.


멤버변수
멤버변수는 실제 데이터를 저장하는 역할을 한다.
private 접근 제한자로 선언한 멤버변수를 인스턴스 멤버변수라고도 한다.

생성자
기본 생성자
기본 생성자는 데이터를 제일 처음에 저장하는 역할인 초기화 작업을 한다.

필드 생성자
필드 생성자는 저장된 데이터를 저장하거나 호출하는 역할을 한다.

메소드
메소드는 문에 대한 실행을 담당하는 { }(코드 블록)을 선언한 메소드이다.
메소드는 저장된 데이터를 수정하거나 조회하여 전달하는 역할을 한다.

추상 메소드
 [접근 제한자] abstract 반환형 추상 메소드명([인자1, 인자2, …인자N]);
 
추상 메소드는 문에 대한 실행을 담당하는 { }(코드 블록)을 선언하지 않은 메소드이다.
추상 메소드는 반환형 앞에 abstract 지정어를 지정해야 한다.
추상 메소드는 오버라이딩에 의해서 코드 블록을 호출한다.
추상 메소드는 코드 블록과 함께 구현되지 않고 상속을 통해서 코드 블록을 구현한다.
추상 메소드는 자식 클래스를 강제하는 특정 메소드의 역할을 한다.



중첩 클래스의 개요
중첩 클래스는 클래스 안에 다른 클래스가 정의되는 것을 의미한다.

중첩 클래스는 클래스 안에 다른 클래스를 가짐으로 클래스 관리의 효율을 높이다.
클래스 안에 클래스를 정의하면은 클래스와 밀접한 관계가 있는 클래스의 자원을 자유롭게 사용할 수가 있다.

중첩 클래스로 정의하지 않으면 다른 클래스의 자원을 이용할 때 모든 자원을 매개변수로 받아서
처리해야 하므로 상당히 복잡해진다.
중첩 클래스에 의해서 생성되는 클래스 안의 클래스 개수는 제한이 없다.
중첩 클래스는 특정 클래스를 클래스의 내부적인 용도로만 사용하고자 할 때 사용하는 효율적인
클래스 개념으로 대표적인 형태가 GUI 이벤트를 처리하는 경우이다.
GUI 화면을 구성하는 클래스가 있고 화면에서 발생하는 이벤트를 처리하는 클래스가 있는 경우에
이벤트를 처리하는 클래스는 GUI 클래스가 없으면 불필요한 클래스가 되므로 독립적인 클래스로
정의하지 않고 GUI 클래스를 중첩 클래스 형태로 작성하면 화면구성 부분과 이벤트 처리 부분이
클래스 형태로 분리되어 같이 사용할 수가 있으므로 효율적으로 되는 것이다.


member Outer 클래스의 멤버 변수나 메소드처럼 클래스가 정의된 경우이다.
local Outer 클래스의 특정 메소드 안에서 클래스가 정의된 경우이다.
static static 지정어를 이용해서 클래스가 정의된 경우이다.
anonymous 익명 클래스를 이용해서 클래스가 정의된 경우이다.

중첩 클래스의 형태

지역 중첩 클래스
예시
public class Outer {
method( ) {
class Inner {
    }
  }
}
지역 중첩 클래스는 Outer 클래스의 특정 메소드 안에서 정의한 클래스이다.
지역 중첩 클래스는 메소드가 호출될 때에 생성되며 메소드가 종료될 때에는 해제된다.
Inner 클래스에서 접근 가능한 변수는 Outer 클래스의 멤버변수와 상수값만 접근할 수 있다.
지역 중첩 클래스는 메소드 내의 로컬변수는 접근할 수 없다.
지역 중첩 클래스에서는 Inner 클래스의 인스턴스 생성은 메소드 내에서 한다.































