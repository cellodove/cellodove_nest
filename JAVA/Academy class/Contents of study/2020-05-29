
인터페이스는 인터페이스고 추상클래스는 추상클래스이다.
추상클래스에서 확장되어 인터페이스가 된것이아니다. 완전 다른 객체임을 인지하자.
생성자가 있고없고 차이다.추상0 인터x

Imp 붙으면 인터페이스에서 붙음을 인지할것


어노테이션 영영사전보면 주석이행이라고 나와있음
어노테이션=라벨 이라고 생각하자.
외래어를 통해서 수행해주는것이다.

뭐든지 왜 쓰는지 알고있자 어떤역할을 하는지

어노테이션을 잘사용할줄알아야함

자바의 리플렉션은 외래어라고 생각하자
열거형 상수 확인 


인터페이스

인터페이스는 클래스에 접근하는 방법을 설정하므로 창구 기능을 한다.
인터페이스는 특정 형태의 클래스들이 사용할 수 있는 메소드의 명세를 정의하는 단위이다.
인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.
코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다.
인터페이스는 코드와 객체 사이에서 통신하게 해주는 접점 역할을 한다.
직접 객체의 메소드를 호출하지 않고 인터페이스라는 중간 매개체를 쓰는 이유는 코드를 수정하지 않고
사용하는 객체를 변경하는 것만으로 편리하게 실행 내용과 반환값을 다양화시킬 수 있기 때문이다.
인터페이스의 구성 요소를 선언하지 않은 인터페이스인 마커 인터페이스는 표시 기능을 가지는 용도로
사용한다.
추상 클래스가 미완성 설계도라고 한다면 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져
있는 기본 설계도라고 할 수 있다.

구분        추상 클래스 인터페이스

멤버변수         가능     불가능
추상메소드       가능       가능
일반메소드       가능     불가능
상수            가능      가능
구현메소드       가능      불가능


인터페이스의 구성 요소

형식
public interface 인터페이스명 {
  [public] [static] [final] 자료형 상수명
  [public] [abstract] 반환형 추상 메소드명;
}

인터페이스는 class 지정어 대신에 interface 지정어를 사용하여 생성한다.
인터페이스명은 클래스명을 작성하는 규칙과 같다.
인터페이스는 추상 메소드와 상수만을 가질 수 있으며 접근 제한자는 public 접근 제한자만 사용한다.


상수
인터페이스는 객체에 대한 사용 설명서이므로 런타임 시에 멤버변수를 선언할 수 없다.
상수는 고정된 값으로 런타임 시에 자료를 바꿀 수 없으므로 상수 선언은 가능하다.
상수를 선언할 때에는 반드시 초기값을 할당한다.
상수는 public static final 문으로 선언하는데 인터페이스의 정적인 객체는 상수밖에 없으므로 생략해도
자동으로 컴파일 과정에서 생성된다.


추상 메소드
인터페이스의 추상 메소드는 추상 클래스의 추상 메소드와 같은 기능을 하고 있다.
인터페이스는 여러 창구의 기능을 하는 메소드가 존재하는 것보다는 통일된 창구의 기능을 하는 메소드를
통해서 구현하는 것이 더 효율적이다.
인터페이스의 추상 메소드는 자식 클래스들에 메소드를 반드시 사용하게 강제한다.
추상 메소드는 public abstract 문으로 선언하는데 인터페이스의 동적인 객체는 추상 메소드밖에 없으므로
생략해도 자동으로 컴파일 과정에서 생성된다.


인터페이스의 상속

형식
구현 클래스 implements 인터페이스명 {
@Override
  [public] 반환형 메소드명 {
  … 실행 내용 …
  }
}

인터페이스에서 구현체를 구현할 때는 implements 명령어를 이용하여 생성한다.
인터페이스는 인스턴스를 생성할 수는 없으므로 인터페이스의 기능을 이용하려면 인터페이스를 클래스로
구현해서 사용해야 한다.
특정 인터페이스를 구현한 클래스는 인터페이스에 정의된 모든 메소드를 구현한다.
인터페이스의 구현 클래스는 인터페이스에서 정의된 추상 메소드의 실체 메소드를 갖고 있어야 한다.
인터페이스는 다른 인터페이스를 상속받을 수 있으며 클래스와는 달리 다중 상속이 가능하다.



인터페이스와 인터페이스의 상속이 가능하며 다중 상속도 허용되다.
상속받은 구현 객체는 하위 및 상위 인터페이스의 자료형으로 변환이 모두 가능하다.
상위 인터페이스로 자료형 변환했을 때 자료형을 변환한 인터페이스에 선언된 메소드만 사용할 수 있다.
다중 상속은 인터페이스 단위로 해당 기능을 정의해 놓고 인터페이스를 implements 명령어를 지정하여
해당 기능을 사용할 수 있다.
인터페이스는 extends 명령어를 이용해서 인터페이스 간에 상속할 수 있다.
실질적으로 호출되는 메소드는 힙 영역에 생성된 클래스 안의 메소드이기 때문에 상속이 모호해질 문제가
일어나지 않는다.



열거형 상수의 개요

형식
접근 제한자 enum 열거형 상수명 {
  요소1, 요소2, 요소3… 요소N
}

열거형 상수는 enum 명령어를 사용하여 선언하고 클래스로 정의한다.
열거형 상수는 관련성이 있는 데이터들을 상수처럼 정의해서 사용한다.
열거형 상수는 JDK 5 버전에서 제공되기 전에는 public static 문으로 변수에 지정해서 사용했다.
열거형 상수가 제공되기 전에 특정 값들을 나열하면서 사용해야 할 때는 주로 int 자료형을 상수로
지정하여 사용했다.

int 형의 상수로 지정하여 사용하는 경우에는 많은 단점이 있으며 단점은 다음과 같다.
자료형이 int 형으로 정해지게 되어 확장성이 떨어지며 상수명이 중복될 위험이 있다.
나열된 값들의 순서를 바꾸거나 상수값을 추가해야 할 때는 반드시 재컴파일이 발생하게 되어 유지 보수가
어려워진다.

int 형의 상수에 대한 단점을 보완하기 위하여 열거형 상수를 지원하고 있다.
열거형 상수는 임의의 메소드나 멤버변수로 열거형 상수를 선언할 수 있다.
열거형 상수는 ==(더블 이퀄) 연산자나 equals 메소드를 이용하여 비교할 수 있다.
열거형 상수는 직렬화도 가능하다.
열거형 상수로 선언된 멤버변수는 오르지 열거형 상수에서 할당된 값만을 가질 수 있다.
열거형 상수는 컬렉션의 단순 버전이라고도 볼 수 있다.
열거형 상수는 특정값만을 가질 수 있는 자료형을 정의할 때 사용한다.


























































































