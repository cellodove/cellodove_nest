

String 클래스의 개요
자바에서 문자열은 내부적으로 배열의 인스턴스 형태로 다루어진다.
String 클래스는 문자열을 다루어 주는 클래스이다.
String 클래스에서 한번 생성한 문자열은 변경되지 않는다.
String 클래스의 메소드를 이용해서 문자열을 가공하면 기존 문자열은 변하지 않고 새로운 가공된 문자열이
생성되므로 문자열 가공이 빈번한 경우에는 StringBuffer 클래스를 사용한다.
String 클래스는 CharSequence 인터페이스, Comparable 인터페이스, Serializable 인터페이스에 의해서
생성된 구현체이다.


CharSequence 인터페이스
CharSequence 인터페이스는 해당 클래스가 문자열을 다루기 위한 클래스임을 명시적으로 나타내며
변형과 가공을 할 수 있다.
자바에서 문자열은 유니코드로 변형하여 보관하므로 HTML과 같이 마크업 문자를 입력하고 출력할 때
문제가 발생할 수가 있지만, CharSequence 인터페이스로 구현한 구현체는 예외를 방지할 수 있다.
CharSequence 인터페이스에 의해서 자바는 XML 문서와 자바 프로그램 간의 호환이 가능하다.

Comparable 인터페이스
Comparable 인터페이스는 비교하려는 매개변수로 넘겨준 객체가 같은지 비교한다.
객체에는 서로 비교할 수 있는 것과 비교할 수 없는 것이 있는데 Comparable 인터페이스로 구현한 객체는
비교할 수 있는 객체이고 그 외는 모두 비교할 수 없는 객체가 된다.

전송한 환경에 맞춰서 전송한 데이터를 변화시켜준다.
EX)www.naver.com 브라우저만나면 저주소로 이동 cd... 도스를 만나면 명령어처럼 작동

Serializable 인터페이스
Serializable 인터페이스는 해당 객체를 파일로 저장하거나 다른 서버로 전송 가능한 상태가 되며 이러한
과정을 직렬화라고 한다.
직렬화는 객체를 컴퓨터에 저장했다가 재사용하거나 네트워크를 통해 컴퓨터 간에 서로 객체를 주고
받는다.
직렬화하는 과정에서 객체는 데이터 스트림화가 되므로 자신의 데이터 상태를 보존할 수가 있다.
자바에서의 객체는 크기가 가변적이고 객체를 구성하는 자료형의 종류들도 다양하므로 직렬화의 과정이
요구되게 된다.

a클래스에있던 b클래스에있던 c클래스에있던 스트링의 값이 같으면 주소는 다같다.
그래서 데이터 전송할때 스트링형식으로 보내는게좋다. 브라우저에서 다 스트링형식으로 데이터를 주고받는이유도 이것이다.


인터페이스는 생성자가 없다. 편리하다
인터페이스와 추상클래스는 기능적으로 같다.

String 클래스의 불변성
String 클래스의 문자열 리터럴 방식은 인스턴스를 생성하면 상수로 인식되기 때문에 한 번 만들어지면
메모리상에 존재하는 문자열을 변경할 수 없는 특성인 불변성을 가진다.
불변성 때문에 문자열을 변경하게 되면 기존의 문자열이 동적으로 변경되지 않고 새로운 문자열이
생성되는데 동적으로 변경되지 않는다는 것은 주소가 변경되지 않는다는 의미다.
String 클래스의 인스턴스는 불변성이 있으므로 변경하는 만큼 인스턴스가 메모리에 계속해서 생성되므로
같은 java라는 같은 단어라도 메모리의 위치가 다르므로 일치하지 않는다.



StringBuffer 클래스

StringBuffer 클래스의 개요
StringBuffer 클래스는 문자열을 다룬다는 점에서 String 클래스와 같지만, String 클래스와는 다른 점은
동적 문자열을 다룬다는 것이다.
메모리상에 문자열을 동적으로 변경하려면 StringBuffer 클래스를 사용한다.
StringBuffer 클래스는 불변성이 없으므로 메소드를 이용해서 문자열을 변경하면 메모리상에서 문자열이
동적으로 변경된다.
StringBuffer 클래스는 버퍼에 생성된 문자열이 변경되며 메소드를 이용해서 문자열을 가공한다.
StringBuffer 클래스는 String 클래스처럼 새로운 문자열이 생성되지 않고 버퍼에 저장된 문자열이
동적으로 변경되므로 문자열 가공이 많은 경우에 효율적이다.
StringBuffer 클래스와 기능이 같은 StringBuilder 클래스가 있으며 차이점은 StringBuilder 클래스는
비동기화 구조이고 StringBuffer 클래스는 동기화 구조다.
동기화와 비동기화의 차이는 동기화는 데이터가 완전히 전송되고 나서 다시 데이터를 전송하지만,
비동기화는 데이터의 전송이 끝나지 않아도 다른 데이터가 전송될 수 있다.
대용량의 데이터를 내려받아 받아 비동기화 방식으로 전송할 때는 StringBuilder 클래스를 사용해야 한다.

wrapper 클래스
wrapper 클래스는 기본 자료형을 클래스인 오브젝트로 만든다.
wrapper 클래스는 기본 자료형을 클래스로 만들어서 클래스가 제공하는 변수와 메소드를 활용해서
기본 자료형을 효율적으로 처리한다.
모든 wrapper 클래스에는 parse 접두어가 붙은 메소드가 제공된다.
형식 parse+wrapper 클래스
parse 접두어가 붙은 메소드는 wrapper 클래스의 기본 자료형으로 강제 변환을 한다.
Integer 클래스
parseInt 메소드
읽어온 데이터를 정수로 분석하여 변환한다.

parseInt(datatype)
§ datatype 매개변수 : 분석할 데이터다.

Float 클래스
parseFloat 메소드
읽어온 데이터를 실수로 분석하여 변환한다.

parseFloat(datatype)
§ datatype 매개변수 : 분석할 데이터다.


박싱(Boxing)
박싱은 기본 자료형을 컬렉션에 직접 저장해도 컴파일러가 자동으로 wrapper 클래스로 변환 후에 저장된다.
wrapper 클래스를 이용해서 기본 자료형의 데이터를 인스턴스 자료형으로 변경한다.

언박싱(UnBoxing)
언박싱은 저장된 값을 얻어 올 때도 직접 기본 자료형으로 얻어 온다.
언박싱에 의해서 인스턴스 자료형의 데이터를 기본 자료형의 변수에 할당하면 자동으로 인스턴스 자료형의
데이터가 기본 자료형으로 변경되면서 할당된다.
wrapper 클래스의 용도는 주로 문자열의 데이터를 다른 자료형의 데이터로 변경할 때 사용된다.




Math 클래스의 개요
Math 클래스는 수학 관련 연산을 처리하는 메소드가 정의된 클래스이다.
간단한 난수 생성을 위해 Math 클래스의 random 메소드를 사용하는 것은 괜찮지만, 성능에 민감한
프로그램을 작성해야 하는 경우라면 Random 클래스를 사용하는 것이 좋다.
Math 클래스의 생성자는 private 접근 제한자로 지정되어 있으므로 생성자를 이용해서 인스턴스를
생성할 수 없다.
Math 클래스의 모든 메소드는 static 지정어로 정의되어 있으므로 다른 클래스에서는 Math 클래스의
메소드를 사용하려면은 Math 클래스에 직접 접근하여 메소드를 호출해서 사용해야 한다


StringTokenizer 클래스의 개요
StringTokenizer 클래스는 지정한 문자열을 특정 구분자로 분리하여 분리된 문자열들을 토큰으로 반환한다.
StringTokenizer 클래스는 특정 데이터를 특정 구분자로 해당 데이터를 구분자로 분리하여 데이터를
추출할 수 있다.
StringTokenizer 클래스는 문자열에서 단어를 분리하는 기능이 있으며 각각의 단어는 구분 기호인
구분자(delimiter)에 의해 토큰으로 분리된다.

StringTokenizer 클래스의 생성자
StringTokenizer 생성자
생성자로 구분자를 사용하여 문자열을 분리하고 토큰을 반환하여 생성한다.
StringTokenizer(String str, String delim)
§ str 매개변수 : 지정된 문자열이다.
§ delim 매개변수 : 지정된 구분자다.

StringTokenizer 클래스의 메소드
hasMoreTokens 메소드
문자열에서 사용할 수 있는 토큰이 더 있는지 테스트한다.
작업할 수 있는 토큰이 더 있는지를 판단한다.
hasMoreTokens( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
nextToken 메소드
문자열에서 다음 토큰을 반환한다.
nextToken( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
countTokens 메소드
저장된 전체 토큰 개수를 반환한다.
nextToken 메소드가 예외를 생성하기 전에 호출할 수 있는 횟수를 계산하여 반환한다.
countTokens( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
hasMoreElements 메소드
열거에 더 많은 요소가 포함되어 있는지 테스트한다.
데이터가 있는지를 검사하고 존재하면 true이고 없으면 false다.
hasMoreElements( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.
nextElement 메소드
요소의 데이터를 반환한다.
열거 개체에 제공할 요소가 하나 이상 더 있는 경우 열거의 다음 요소를 반환한다.
nextElement( )
§ ( )(퍼렌씨시스) 심볼 : 매개변수가 없이 독립적으로 수행한다.




Random 클래스의 개요
Random 클래스는 임의의 값을 발생시켜 주는 의사 난수 발생기로 일정 범위의 값들에서 한 개의 수를
임의로 선택한다.
Random 클래스의 인스턴스를 호출할 때 생성되는 난수들이 달라지는 seed 값으로 임의의 난수값을 얻는다.
seed 값을 일반적으로 현재 시각을 이용하며 매번 다르게 주어 매번 다른 의사 난수를 추출한다.
매 순간 현재 시각이 바뀌며 한 번 지나간 시간은 다시 돌아오지 않는다는 특성에 의해 이전에 발생했던
의사 난수를 다시 재연 불가능하게 만들며 시간이 밀리초 단위로 섬세하게 표현된다면 사람에 의한
임의적 조작도 사실상 불가능해진다.
float 자료형으로 의사 난수를 발생시키면 0.0에서 1.0의 범위에서 추출한다.
난수에 대한 필요성은 빈번히 발생하는데 특히 보안 코드를 생성할 때 난수를 사용한다.



Date 클래스의 개요
Date 클래스는 날짜와 시간에 관한 정보 클래스이다.
Date 클래스는 자바의 JDK가 버전이 상향되면서 많은 메소드가 사용되지 않고 앞으로는 사라지게 되었다.
Date 클래스보다는 가능하면 Calendar 추상 클래스를 사용하는 것을 권장한다.


Calendar 추상 클래스의 개요
Calendar 추상 클래스는 Date 클래스처럼 날짜와 시간에 관한 정보를 표현할 때 사용한다.
Date 클래스에서 사라진 메소드 중에 같은 기능의 메소드가 Calendar 추상 클래스에서 제공된다.
Calendar 추상 클래스는 getInstance 스테틱 메소드를 이용하여 인스턴스를 생성한다.
Calendar 추상 클래스의 상수
YEAR : 현재 년도
MONTH : 현재 월
DATE : 현재 월의 날짜
WEEK_OF_YEAR : 현재 연도의 주
WEEK_OF_MONTH : 현재 월의 주
DAY_OF_YEAR : 현재 연도의 날짜
DAY_OF_MONTH : 현재 월의 날짜
DAY_OF_WEEK : 현재 요일로 일요일은 1, 토요일은 7이다.
HOUR : 12시간제의 현재시간
HOUR_OF_DAY : 24시간제의 현재시간
MINUTE : 현재 분
SECOND : 현재 초




























































