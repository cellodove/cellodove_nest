
패키지를 각 기능별로 나눈다.

그중에 모델 패키지에는 멤버변수만 넣는다. 저장기능을 담당한다.
모델 패키지에서 호출(get) 저장(set)메소드를 사용한다.

서비스 패키지에서는 메소드만한다.

모든데이터의 접근은 모델이다.

그래서 프로젝트를 할때 첫째는 패키지의 생성 둘째는 클래스명 정하기이다.

package a.b.c.model;

public class SearchCommand {
	//모델에는 멤버변수만 넣는다.
	private String name;
	private int age;
	
	//인스턴스 멤버변수의 변수값을 한꺼번에 임시로 저장한다.
	public SearchCommand(String name, int age) {
	
		this.name = name;
		this.age = age;
	}

	//이름을 반환한다.
	public String getName() {
		return name;
	}
	
	//나이를 반환한다.
	public int getAge() {
		return age;
	}
}
//프라이빗하기때문에 위와같이 하는것 맴버변수를 바로 바꾸게하는것이아니라
//메소드로만 연결되게 하는것이다.잘못저장할수있는경우를 미연에 방지
//생성자 사용하는이유 프라이빗 맴버변수에 직접 접근이 불가능하기때문에 접근하기위해 사용
//클래스가 동작을 하면 생성자이고 클래스가 아닌게 동작을 하면 메소드이다.


package a.b.c.service;

import a.b.c.model.SearchCommand;

public class SearchService {
	//1차원 배열을 생성한다.
	SearchCommand[] searchCommands = new SearchCommand[2];

	public SearchService() {
	
		searchCommands[0] = new SearchCommand("홍길동", 33);
		searchCommands[1] = new SearchCommand("제임스", 67);
	}
	boolean searchResult = false;
	
	
	
	
}


//////////////////////////////////////////////////////////////////////////////////////


package a2020_05_25;
//클래스가 메소드의 기능을 담당하면 생성자라고한다.
public class A {
	//저장기능 컬럼과 같다.
	int age=300;
	//생성자로 이용해서 저장한다.
	//필드 생성자라고 이야기한다.
	
	//기본 생성자 = 초기화 생성자

	
	String name;
	//일괄저장 필드 생성자
	public A(int age, String name) {
		super();
		this.age = age;
		this.name = name;
	}
	
	
	//기본생성자 아무것도 없어도 호출가능 가장먼저 호출되는것
	public A() {
		
		System.out.println("dd");
	}
	
	//스트링으로 보고싶다 to스트링 생성자
	@Override
	public String toString() {
		return "A [age=" + age + ", name=" + name + "]";
	}

	//개별호출 저장
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	
}

package a2020_05_25;

public class B {

	//기본메소드
	public static void main(String[] args) {
		A a = new A();
		System.out.println(a);
		
	}
}


////////////////////////////////////////////////////////////////////
클래스를 선언하면 자동으로 생성자가 생성됨.


생성자가 필요한이유

클래스가 움직일수있어야 서로 접근할수있다.
그래서 클래스에 동작할수있도록 넣어주어야한다.

즉 클래스에 접근하기위해 생성자가 필요하다.

서로 악수를 하기위해서는 손이던지 발이던지 움직일수있어야한다. 생성자가 이렇게 동작하는것을 내포하고있다.


메소드는 인스턴스를 통해 공통된 가능을 사용하는것

리턴은 실행된 내용을 반환시켜주는것


용어와 메서드 생산자 확실하게 익히자

생산자는 접근허용
메서드는 공통된 기능


기본 생성자
기본 생성자는 데이터를 제일 처음에 저장하는 역할인 초기화 작업을 한다.
기본 생성자는 초기화 작업을 하므로 초기화 생성자라고도 한다.
기본 생성자는 인스턴스가 생성될 때에 호출되는 인스턴스 멤버변수의 초기화 작업을 수행한다.



필드생성자
필드 생성자는 저장된 데이터를 저장하거나 호출하는 역할을 한다.
필드 생성자는 기본 생성자에 멤버변수를 매개변수인 인자로 지정한다.
필드 생성자는 인자 리스트만 다르면 같은 클래스에서 여러 번 사용할 수 있다.
필드 생성자의 인자 리스트를 변경하여 사용할 수 있으므로 오버 로딩 생성자라고 한다.
필드 생성자는 다음과 같은 작성 규칙을 가진다.
필드 생성자는 일반적으로 인스턴스 멤버변수를 한꺼번에 임시로 저장할 때 사용한다.


클래스의 매소드
메소드는 메소드명에 ( )(퍼렌씨시스) 추가하여 생성하고 퍼렌씨시스에 인자를 추가하거나 생략한다.
메소드는 여러 개의 작업을 하나로 묶어서 관리할 수 있는 작업의 덩어리이다.
메소드는 자주 반복하여 사용하는 내용에 대해 특정 이름으로 정의한 묶음으로 데이터를 전송한다.
메소드는 저장된 데이터를 수정하거나 조회하여 전달하는 역할을 한다.
메소드는 작업을 하나로 묶어서 관리할 수 있기에 아주 효율적이다.
메소드를 호출할 때에는 매개변수인 인자의 개수와 인자의 자료형을 맞추어서 호출해야 한다.
메소드의 이름은 일반적으로 동작적인 의미가 있는 것을 사용한다.
메소드는 필요하면 인스턴스를 통해서 반복적으로 호출할 수 있다.
메소드는 인스턴스를 통해서 오브젝트의 메시지를 전송한다.
메시지는 송신 오브젝트가 실행을 원하는 수신 오브젝트의 메소드를 호출하여 메소드의 매개변수인 인자로 전달한다.

메소드 앞에는 반드시 반환형이 존재해야 하며 반환형은 모든 자료형이 된다.
메소드의 return 문으로 반환하는 반환값과 선언부에 명시된 반환형은 반드시 일치해야 한다.
메소드에서 특정값을 반환하고자 할 때만 return 문으로 반환값을 반환한다.
특정값을 반환할 때에 반환할 결과값이 없을 때는 선언부에 명시된 반환형으로 초기화를 해야 한다.
return 문으로 반환값을 반환하지 않고 return 문만 반환하면은 void 반환형으로 지정하며 return 문은
생략할 수 있다.
void 반환형은 return 문을 사용하지 않아도 되고 반환하는 값을 지정하지 않아도 된다.
return 문은 메소드를 실행하고 메소드를 호출한 위치로 특정값을 반환하는 경우에 반환하는 자료형의
값을 지정하는 부분이다.
return 문은 메소드를 호출한 부분으로 특정값을 반환해 주는 용도로도 사용된다.


메소드의 호출
이름에 의한 호출(Call By Name)
메소드의 이름으로 호출되는 메소드로 특정 매개변수 없이 실행한다.

주소에 의한 호출(Call By Reference)
메소드를 호출할 때에 매개변수로 사용되는 값이 특정 주소를 참조하여 실행한다.

값에 의한 호출(Call By Value)
메소드를 이름으로 호출할 때 특정 매개변수를 전달하여 전달한 값을 실행한다.

일반 자료형 반환
형식
//[접근 제한자][지정어] 자료형 메소드명([인자1, 인자2….인자N]) {
//… 실행 내용 …
//return 반환값;
//}
일반 자료형으로 반환하면 return 문으로 자료형의 값인 반환값을 반환해야 한다.
일반 자료형으로 반환하면 메소드의 인자인 매개변수를 전달할 때는 인자값이 복사되어 전송된다.










